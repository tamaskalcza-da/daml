# Azure Pipelines file, see https://aka.ms/yaml

# Enable builds on all branches
trigger:
  # Build every commit as our release process relies on
  # the release process being built alone.
  batch: false
  branches:
    include:
      - master

# Enable PR triggers that target the master branch
pr:
  autoCancel: true # cancel previous builds on push
  branches:
    include:
      - master

jobs:
  - job: collect_build_data
    condition: always()
    pool:
      name: "linux-pool"
    variables:
      # Using expression syntax so we get an empty string if not set, rather
      # than the raw $(VarName) string. Expression syntax works on the
      # variables key, but not on the env one, so we need an extra indirection.
      # Note: These Azure variables are only set for PR builds.
      pr.num: $[ variables['System.PullRequest.PullRequestNumber'] ]
      pr.branch: $[ variables['System.PullRequest.SourceBranch'] ]
    steps:
      # some change in Azure configuration makes this fail recently (2020-01).
      # Azure runs PR builds not on the PR commit, but on the GitHub-provided
      # commit that would be the result of merging the PR. Recently, it looks
      # like when it reaches the point of running this job (which has to run
      # after the macOS one, which sometimes takes up to an hour), if master
      # has changed in the meantime, Azure cannot find the commit it wants to
      # build anymore. Therefore, we tell it not to checkout anything, and
      # manually checkout the PR commit.
      - checkout: none
      - bash: |
          set -euo pipefail
          # Note: this is going to get the current master commit, not the
          # result of the merge (i.e. this is not using the same commit as the
          # other jobs in this build). This seems good enough here as all we
          # really want is the dev-env, and conflicts should be pretty rare
          # there. It _does_ mean this may fail to catch changes that would
          # break this job, e.g. incompatible updates of jq or gcloud.
          # Note: Azure doe snot guarantee a clean workspace and dev-env
          # doesn't nest, so we need to handle both a clean slate and an
          # existing, dirty workspace.
          if [ -d .git ]; then
              git fetch
              git reset --hard
              git clean -xffd
              git checkout origin/master
          else
              git clone https://github.com/digital-asset/daml.git ./
          fi
          eval "$(./dev-env/bin/dade-assist)"

          tell_slack () {
            local MESSAGE=$1
            curl -XPOST \
                 -i \
                 -H 'Content-type: application/json' \
                 --data "{\"text\":\"<!here> *FAILED* $(Agent.JobName): <https://dev.azure.com/digitalasset/daml/_build/results?buildId=$(Build.BuildId)|$MESSAGE>\n\"}" \
                 $(Slack.URL)
          }

          REPORT=$(mktemp)
        env:
          GOOGLE_APPLICATION_CREDENTIALS_CONTENT: $(GOOGLE_APPLICATION_CREDENTIALS_CONTENT)
          # Commit message is always set
          COMMIT_MSG: $(Build.SourceVersionMessage)
          # Because these variables are always set (in the variables block),
          # hopefully these should be set as expected (i.e. either correct
          # value or empty string, but not $(Azure.Variable.Name)).
          PR_NUM: $(pr.num)
          PR_BRANCH: $(pr.branch)
